import os, sys
import json, json.tool

# The script purposed for fix oldest data generated by the program versions before implementation of sorting of translations by language
# It reads a *-segs.json file, sorts the data and writes into a new fixed file.

# Read Json data fron the input file
def readJson(inputFileP):
    if not os.path.isfile(inputFileP):
        raise Exception("Cannot read %s" % inputFileP)

    inputFile = open(inputFileP, "r", encoding="utf-8-sig")
    if not inputFile.readable():
        raise Exception("Cannot read %s" % inputFileP)

    content = inputFile.read()
    jsonData = json.loads(content)

    return jsonData

# Find the langMark in the string, like '[de]', '[fr] ...
def getLngMark(srcDef):
    # default (no language mark)
    ret = "[--]"
    if srcDef.startswith("["):
        ret = srcDef[0:4]
    return ret

# Help function: 
# for the lngMark, find the index position in idx['idx']
# Append all entries found at this position in idx['vals'] into the given list valsNew
def appendForLngMark(lngMark, idx, valsNew):
    if lngMark in idx['idx']:
        pos = idx['idx'].index(lngMark)
        for val in idx['vals'][pos]:
            valsNew.append(val)

# Resort the given Json dict senses for have first entries with language [de], 
# then entries without language, then entries sorted by language alphabetically
# The input structure will be overwritten.
def resortSenses(senses):
    idx = {
        "idx" : [],
        "vals" : []
    }
    
    for sense in senses:
        srcDef = sense['srcDef']
        lngMark = getLngMark(srcDef)
        vals = list()
        if lngMark in idx['idx']:
            pos = idx['idx'].index(lngMark)
            vals = idx['vals'][pos]
        else:
            idx['idx'].append(lngMark)
            idx['vals'].append(vals)
        vals.append(srcDef)
        
    valsNew = list()
    # entries with DE lang
    appendForLngMark("[de]", idx, valsNew)
    # entries without lang
    appendForLngMark("[--]", idx, valsNew)
    # other entries: sorted alphabetically
    idxCopy = idx['idx'].copy()
    idxCopy.sort()
    for lngMark in idxCopy:
        if(lngMark != "[de]" and lngMark != "[--]"):
            appendForLngMark(lngMark, idx, valsNew)

    # overwrite the provided data by sorted entries
    senses.clear()
    for vn in valsNew:
        sense = {
            'srcDef': vn
        }
        senses.append(sense)

# Overwrite the jsonData structure by sort the 'senses' member for each entry in jsonData['dictEntries']
def resortDictEntries(jsonData):
    dic = jsonData['dictEntries']
    for dicEntry in dic:
        resortSenses(dicEntry['senses'])

# Store the output file
def storeModFile(jsonData, outputFileP):
    outputFile = open(outputFileP, "w", encoding="utf8")
    if not outputFile.writable():
        raise Exception("Cannot write into %s" % outputFileP)
    json.dump(jsonData, outputFile, ensure_ascii=False, indent=2)

if __name__ == '__main__':
    if len(sys.argv) != 3:
        exit("Usage: INPUT_FILE <Mandatory: input file name> OUTPUT_FILE <Mandatory: output file name>")
    
    inputFileP  = os.path.abspath(sys.argv[1])
    outputFileP = os.path.abspath(sys.argv[2])
    
    if inputFileP == outputFileP:
        exit ("Error: input same as output %s" % outputFileP)

    try :
        jsonData = readJson(inputFileP)
        resortDictEntries(jsonData)
        storeModFile(jsonData, outputFileP)
        exit("File created: %s" % outputFileP)
    except Exception as e:
        exit ("Error: %s" % str(e))